# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

"""Flow config base class."""

import json
import os
import pprint
import sys
from abc import abstractmethod
from argparse import Namespace
from collections.abc import Mapping, Sequence
from pathlib import Path
from typing import ClassVar

from dvsim.job.deploy import Deploy
from dvsim.launcher.factory import get_launcher_cls
from dvsim.logging import log
from dvsim.project import Project
from dvsim.scheduler import Scheduler
from dvsim.utils import (
    find_and_substitute_wildcards,
    md_results_to_html,
    mk_path,
)


# Interface class for extensions.
class FlowCfg:
    """Base class for the different flows supported by DVSim."""

    # Set in subclasses. This is the key that must be used in an hjson file to
    # tell dvsim.py which subclass to use.
    flow = None

    # Can be overridden in subclasses to configure which wildcards to ignore
    # when expanding hjson.
    ignored_wildcards: ClassVar = []

    def __str__(self) -> str:
        """Get string representation of the flow config."""
        return pprint.pformat(self.__dict__)

    def __init__(
        self,
        *,
        flow_cfg_file: Path,
        project_cfg: Project,
        config_data: Mapping,
        args: Namespace,
        child_configs: Sequence["FlowCfg"] | None = None,
    ) -> None:
        """Initialise the flow."""
        self._project_cfg = project_cfg
        self._config_data = dict(config_data)
        if "cfgs" in self._config_data:
            del self._config_data["cfgs"]

        # Take the configs as provided
        self.cfgs: Sequence[FlowCfg] = child_configs or []

        # Options set from command line
        # Uniquify input items, while preserving the order.
        self.items = list(dict.fromkeys(args.items))
        self.list_items = args.list
        self.select_cfgs = args.select_cfgs
        self.flow_cfg_file = flow_cfg_file
        self.args = args
        self.gui = args.gui
        self.gui_debug = args.gui_debug
        if self.gui_debug:
            self.gui = 1

        self.interactive = args.interactive

        # Options set from hjson cfg.
        self.project = ""

        # Add exports using 'exports' keyword - these are exported to the child
        # process' environment.
        self.exports = []

        # Add a notion of "primary" cfg - this is indicated using
        # a special key 'use_cfgs' within the hjson cfg.
        self.is_primary_cfg = child_configs is not None

        # For a primary cfg, it is the aggregated list of all deploy objects
        # under self.cfgs. For a non-primary cfg, it is the list of items
        # slated for dispatch.
        self.deploy: Sequence[Deploy] = []

        # Timestamp
        self.timestamp_long = args.timestamp_long
        self.timestamp = args.timestamp

        # Results
        self.errors_seen: bool = False
        self.rel_path = ""
        self.results_title = ""
        self.revision = ""
        self.css_file = Path(__file__).resolve().parent / "style.css"
        # `self.results_*` below will be updated after `self.rel_path` and
        # `self.scratch_base_root` variables are updated.
        self.results_dir = ""
        self.results_page = ""
        self.results_html_name = ""

        # Full results in md text
        self.results_md = ""
        # Selectively sanitized md results to be published
        self.publish_results_md = ""
        self.sanitize_publish_results = False
        # Summary results, generated by over-arching cfg
        self.results_summary_md = ""

        # These are for temporary backward compatibility and wildcard expansion
        self.proj_root = self._project_cfg.root_path
        self.scratch_root = self._project_cfg.scratch_path
        self.branch = self._project_cfg.branch
        self.job_prefix = self._project_cfg.job_prefix

        # Merge in the values from the loaded config file.
        self.__dict__.update(self._config_data)

        # Expand wildcards. If subclasses need to mess around with parameters
        # after merging the hjson but before expansion, they can override
        # _expand and add the code at the start.
        self._expand()

        # Construct the path variables after variable expansion.
        self.results_dir = Path(self.scratch_base_path) / "reports" / self.rel_path
        self.results_page = self.results_dir / self.results_html_name

    def _expand(self) -> None:
        """Expand wildcards after merging hjson.

        Subclasses can override this to do something just before expansion.

        """
        # If this is a primary configuration, it doesn't matter if we don't
        # manage to expand everything.
        partial = self.is_primary_cfg

        # If custom dump script is exist, replace with run_script attribute.
        if self.args.dump_script is not None:
            self.run_script = "{proj_root}/" + self.args.dump_script

        self.__dict__ = find_and_substitute_wildcards(
            obj=self.__dict__,
            wildcard_values=self.__dict__,
            ignored_wildcards=self.ignored_wildcards,
            ignore_error=partial,
        )

    def _purge(self) -> None:
        """Purge the existing scratch areas in preparation for the new run."""

    def purge(self) -> None:
        """Public facing API for _purge()."""
        for item in self.cfgs:
            item._purge()

    @abstractmethod
    def _print_list(self) -> None:
        """Print the list of available items that can be kicked off."""

    def print_list(self) -> None:
        """Public facing API for _print_list()."""
        for item in self.cfgs:
            item._print_list()

    def prune_selected_cfgs(self) -> None:
        """Prune the list of configs for a primary config file."""
        # If the user didn't pass --select-cfgs, we don't do anything.
        if self.select_cfgs is None:
            return

        # If the user passed --select-cfgs, but this isn't a primary config
        # file, we should probably complain.
        if not self.is_primary_cfg:
            log.error(
                f"The configuration file at {self.flow_cfg_file!r} is not a primary "
                "config, but --select-cfgs was passed on the command "
                "line.",
            )
            sys.exit(1)

        # Filter configurations
        self.cfgs = [c for c in self.cfgs if c.name in self.select_cfgs]

    @abstractmethod
    def _create_deploy_objects(self) -> None:
        """Create deploy objects from items that were passed on for being run.

        The deploy objects for build and run are created from the objects that
        were created from the create_objects() method.
        """

    def create_deploy_objects(self) -> None:
        """Public facing API for _create_deploy_objects()."""
        self.prune_selected_cfgs()

        # GUI, GUI debug or Interactive mode is allowed only for one cfg.
        if (self.gui or self.gui_debug or self.interactive) and len(self.cfgs) > 1:
            log.fatal("In GUI mode, only one cfg can be run.")
            sys.exit(1)

        for item in self.cfgs:
            item._create_deploy_objects()

    def deploy_objects(self) -> Mapping[Deploy, str]:
        """Public facing API for deploying all available objects.

        Runs each job and returns a map from item to status.
        """
        deploy = []
        for item in self.cfgs:
            deploy.extend(item.deploy)

        if not deploy:
            log.error("Nothing to run!")
            sys.exit(1)

        if os.environ.get("DVSIM_DEPLOY_DUMP", "true"):
            filename = f"deploy_{self.branch}_{self.timestamp}.json"
            (Path(self.scratch_root) / filename).write_text(
                json.dumps(
                    # Sort on full name to ensure consistent ordering
                    sorted(
                        [d.model_dump() for d in deploy],
                        key=lambda d: d["full_name"],
                    ),
                    indent=2,
                ),
            )

        return Scheduler(
            items=deploy,
            launcher_cls=get_launcher_cls(),
            interactive=self.interactive,
        ).run()

    @abstractmethod
    def _gen_results(self, results: Mapping[Deploy, str]) -> str:
        """Generate flow results.

        The function is called after the flow has completed. It collates
        the status of all run targets and generates a dict. It parses the log
        to identify the errors, warnings and failures as applicable. It also
        prints the full list of failures for debug / triage to the final
        report, which is in markdown format.

        results should be a dictionary mapping deployed item to result.
        """

    def gen_results(self, results: Mapping[Deploy, str]) -> None:
        """Public facing API for _gen_results().

        results should be a dictionary mapping deployed item to result.

        """
        for item in self.cfgs:
            json_str = (
                item._gen_json_results(results) if hasattr(item, "_gen_json_results") else None
            )
            result = item._gen_results(results)
            log.info("[results]: [%s]:\n%s\n", item.name, result)
            log.info("[scratch_path]: [%s] [%s]", item.name, item.scratch_path)
            item.write_results(self.results_html_name, item.results_md, json_str)
            log.verbose("[report]: [%s] [%s/report.html]", item.name, item.results_dir)
            self.errors_seen |= item.errors_seen

        if self.is_primary_cfg:
            self.gen_results_summary()
            self.write_results(self.results_html_name, self.results_summary_md)

    @abstractmethod
    def gen_results_summary(self) -> None:
        """Public facing API to generate summary results for each IP/cfg file."""

    def write_results(self, html_filename: str, text_md: str, json_str: str | None = None) -> None:
        """Write results to files.

        This function converts text_md to HTML and writes the result to a file
        in self.results_dir with the file name given by html_filename.  If
        json_str is not None, this function additionally writes json_str to a
        file with the same path and base name as the HTML file but with '.json'
        as suffix.
        """
        results_dir = Path(self.results_dir)
        mk_path(results_dir)

        # Write results to the report area.
        (results_dir / html_filename).write_text(
            md_results_to_html(self.results_title, self.css_file, text_md)
        )

        if json_str is not None:
            filename = Path(html_filename).with_suffix(".json")
            (results_dir / filename).write_text(json_str)

    def _get_results_page_link(self, relative_to: str, link_text: str = "") -> str:
        """Create a relative markdown link to the results page."""
        link_text = link_text if link_text else self.name.upper()
        relative_link = os.path.relpath(self.results_page, relative_to)
        return f"[{link_text}]({relative_link})"

    def has_errors(self) -> bool:
        """Return error state."""
        return self.errors_seen
